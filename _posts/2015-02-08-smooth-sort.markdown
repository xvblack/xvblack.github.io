---
title: SmoothSort
layout: post
date: 2015-02-08 16:25
category: Algorithm

---
SmoothSort是上古大神Dijkstra提出的基于Heap和String的排序算法。其特点在于：

1. Stable
2. 最好运行时间为O(N)

引用一张来自维基的排序演示图：

![smooth sort](/images/Smoothsort.gif)

来自维基百科

\# 非常炫酷

其排序主要基于两个特性

1. Leonardo数大小的堆
2. String Property，亦即每个堆的根节点比其左边兄弟堆的根节点大。

Leonardo Number，是指按如下规律生成的序列：

	f(N) = f(N-1) + f(N-2) + 1
	f(1) = f(0) = 1

SmoothSort的实现可以被视为一个two pass的过程，一次入堆，一次出堆。而与传统的堆排序不同，其最上面的结构是一个上文提到的String，即一组有序的堆，而不是一个堆。所以更加贴切的说法应该是维持了一个堆的栈。直观来说，每当我们看到一个新的元素，希望将其入栈的时候，我们有两种情况：

1. 栈顶的两个堆恰好形成Leonardo数关系，即一个的大小是f(N-1)，一个的大小是f(N-2)，这时我们很自然的希望合并这两个堆，并生成一个新的堆，大小是f(N)
2. 如果条件不符合，我们希望压入一个f(1)或者f(0)的新堆。我们自然不希望连续压入两个f(1)，否则之后的合并操作就无法进行

而这些合并，建堆操作会保持上文提到的特性1，但会破坏上文提到的特性2。所以每次我们进行了上述操作后，我们都要重新调整栈中堆的根节点，使得栈中的堆仍保持有序，而做法则是对这些根节点进行一次插入排序。因为之前的节点是有序的，所以我们只需要找到一个合适的位置插入新节点即可。而新节点的插入又可能会破坏特性1，所以我们对插入的堆重新进行堆修复。

通过这样的操作，我们可以将所有的节点压入栈，并且保持特性1和特性2。而这时的问题便变成了如何将最大的元素一一取出。我们知道，最右边的堆的根节点必然是最大的元素，所以我们只需要将最右边的堆拆开，然后将左右子树放回即可。放回的操作仍可能破坏特性2，所以我们还是要进行两次上一段中提到的修复操作。按照此顺序助词的得到最大值，既可以达到排序的目的。

SmoothSort相较于堆排序最好的特性在于如果原始数组是排好序的，或者接近排好序的，其复杂度可以达到或者接近线性。但与堆排序相同，SmoothSort是不稳定的。并且相较于QuickSort，SmoothSort并不具有良好的Spatial Locality，特别是对于根节点的插入排序操作，所以缓存表现会不如QuickSort。